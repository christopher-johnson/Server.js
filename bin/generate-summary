#!/usr/bin/env node

/*! @license Â©2014 Miel Vander Sande - Multimedia Lab / iMindata / Ghent University */
/** This script generates data summaries for a certain server dataset  */

var _ = require('lodash'),
  N3 = require('n3'),
  fs = require('fs'),
  path = require('path'),
  _ = require('lodash');

var regex = /^(http[s]?:\/?\/?[^:\/\s]+\/).*/;

var DS_NS = 'http://semweb.mmlab.be/ns/datasummaries#',
  RDF_NS = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#';

// Parse arguments
var args = process.argv.slice(2);
if (args.length < 1 || args.length > 2) {
  console.error('usage: generate-summary config.json [datasourceName]');
  return process.exit(1);
}

// Init variables
var configFile = args[0],
  config = JSON.parse(fs.readFileSync(configFile)),
  datasources = config.datasources || {},
  datasourceNames = args[1] ? [args[1]] : (config.datasources && _.keys(config.datasources));

// Configure preset URLs
var baseURL = config.baseURL ? config.baseURL.replace(/\/?$/, '/') : '/',
  baseURLRoot = baseURL.match(/^(?:https?:\/\/[^\/]+)?/)[0],
  baseURLPath = baseURL.substr(baseURLRoot.length),
  blankNodePath = baseURLRoot ? '/.well-known/genid/' : '',
  blankNodePrefix = blankNodePath ? baseURLRoot + blankNodePath : 'genid:',
  hostname = require('url').parse(baseURL).hostname,
  datasourceBase = baseURLPath.substr(1);

generate(datasourceNames.pop());

function generate(datasourceName) {
  // Create data source
  var datasourceConfig = config.datasources[datasourceName];

  try {
    // Avoid illegal URI characters in data source path
    var datasourcePath = datasourceBase + encodeURI(datasourceName);

    // Retrieve the data source class and settings
    var Datasource = require(path.join('../lib/datasources/', datasourceConfig.type)),
      settings = _.defaults(datasourceConfig.settings || {}, config);

    // Create the data source
    var datasource = new Datasource(settings),
      url = baseURLRoot + '/' + datasourcePath;

    var writer = N3.Writer({
      prefixes: {
        'ds': DS_NS,
        'rdf': RDF_NS
      }
    });

    fromDataSource(url, datasource, function (triple) {
      writer.addTriple(triple);
    }, function () {
      writer.end(function (error, result) {
        //console.log(result);
        fs.appendFileSync(datasourceName + '.ttl', result);
        (datasourceNames.length > 0) && generate(datasourceNames.pop());
      });
    });

  } catch (error) {
    process.stderr.write('Could not load datasource ' + datasourceName + ': ' + error.message + '\n');
    return process.exit(1);
  }
}

function fromDataSource(uri, dataSource, callback, end, chunksize) {
  var hrstart = process.hrtime();

  var capabilities = Object.create(null),
    supportsQuery = dataSource.supportsQuery({
      features: {
        limit: true,
        offset: true
      }
    });

  if (supportsQuery) {
    processSet(chunksize || 100000);
  } else {
    // Process dataset at once
    dataSource.select({}, function (err) {
        console.error('Error occured', err);
      })
      .on('data', extractSummary)
      .on('end', endSummary);
  }

  // Processes DataSource in chunks
  function processSet(limit, offset) {
    offset = offset || 0;
    var count = 0;

    var stream = dataSource.select({
        limit: limit,
        offset: offset
      }, function (err) {
        console.error('Error occured', err);
      })
      .on('metadata', function (metadata) {
        var progress = Math.round((offset / metadata.totalCount) * 100);
        console.log(progress);

        stream.on('data', function (triple) {
          count++;
          extractSummary(triple);
          triple = null;
        });

        stream.on('end', function () {
          stream.removeAllListeners();
          stream = null;

          if (count < limit)
            endSummary();
          else
            setImmediate(function () {
              processSet(limit, offset + limit);
            });
        });
      });
  }

  function extractSummary(triple) {
    // Check is a capability already exists
    if (!capabilities[triple.predicate])
      capabilities[triple.predicate] = {
        subjectAuth: {},
        objectAuth: {}
      };

    var subjectAuth = regex.exec(triple.subject),
      objectAuth = regex.exec(triple.object);

    if (subjectAuth !== null) {
      subjectAuth = subjectAuth[1].toLowerCase();
      capabilities[triple.predicate].subjectAuth[subjectAuth] = null;
    }

    if (objectAuth !== null) {
      objectAuth = triple.predicate === RDF_NS + 'type' ? triple.object : objectAuth[1].toLowerCase();
      capabilities[triple.predicate].objectAuth[objectAuth] = null;
    }
  }

  function endSummary() {
    var cnt = 0,
      baseUrl = '_:summary';

    for (var predicate in capabilities) {
      var bnode = '_:cap' + cnt++;
      callback({
        subject: baseURL,
        predicate: DS_NS + 'capability',
        object: bnode
      });

      callback({
        subject: bnode,
        predicate: DS_NS + 'predicate',
        object: predicate
      });

      var capability = capabilities[predicate];

      for (var subjectAuth in capability.subjectAuth) {
        callback({
          subject: bnode,
          predicate: DS_NS + 'sbjAuthority',
          object: subjectAuth
        });
      }

      for (var objectAuth in capability.objectAuth) {
        callback({
          subject: bnode,
          predicate: DS_NS + 'objAuthority',
          object: objectAuth
        });
      }
    }

    var hrend = process.hrtime(hrstart);
    //console.error('Data Summary completed %d ms', (hrend[0] * 1e9 + hrend[1]) / 1000000);
    console.log(100);
    end();
  }
}
